/// <reference types="node" />
/*
 * AGLint v2.0.9 (build date: Thu, 25 Apr 2024 09:15:58 GMT)
 * (c) 2024 AdGuard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/AGLint#readme
 */
import { AdblockSyntax, AnyRule, Node } from '@adguard/agtree';
import { Struct } from 'superstruct';
import { ParsedPath } from 'node:path';
import { Ignore } from 'ignore';

/**
 * Represents the possible severities of a linter rule
 */
declare const SEVERITY: Readonly<{
    /**
     * Rule is disabled, nothing happens
     */
    off: 0;
    /**
     * Rule is enabled, and throws a warning when violated.
     *
     * @example Bad practices, deprecated syntax, formatting issues, redundant rules, etc.
     */
    warn: 1;
    /**
     * Rule is enabled, and throws an error when violated.
     *
     * @example Unknown scriptlets, unknown modifiers, etc.
     */
    error: 2;
    /**
     * Rule is enabled, and throws a fatal error when violated.
     *
     * @example Syntax error (parsing error)
     */
    fatal: 3;
}>;
/**
 * Type for the possible severity names
 */
type SeverityName = keyof typeof SEVERITY;
/**
 * Type for the possible severity values
 */
type SeverityValue = typeof SEVERITY[SeverityName];
/**
 * Type for the possible severities
 */
type AnySeverity = SeverityName | SeverityValue;

/**
 * Represents any linter rule
 */
type AnyLinterRule = LinterRule<any, any>;
/**
 * Type for rule configuration object
 */
type LinterRuleConfigObject = {
    [key: string]: LinterRuleConfig;
};
/**
 * Type definition for the linter rule config, which can be:
 * - severity itself (number or string): `severity`
 * - one-element array with severity as the first element: `[severity]`
 * - n-element array with severity as the first element and other options as the rest: `[severity, ...options]`
 */
type LinterRuleConfig = AnySeverity | LinterRuleConfigArray;
/**
 * Type definition for the linter rule config array, which can be:
 * - one-element array with severity as the first element: `[severity]`
 * - n-element array with severity as the first element and other options as the rest: `[severity, ...options]`
 */
type LinterRuleConfigArray = [AnySeverity, ...unknown[]];
/**
 * Represents the metadata of a linter rule configuration
 */
interface LinterRuleConfigMeta {
    /**
     * Default configuration of the rule
     */
    default: unknown;
    /**
     * Superstruct schema for the rule configuration (used for validation)
     */
    schema: Struct;
}
/**
 * Represents the metadata of a linter rule
 */
interface LinterRuleMeta {
    /**
     * Linter rule severity. It can be off, warn, error or fatal.
     */
    severity: AnySeverity;
    /**
     * Configuration metadata (if the rule has any configuration)
     */
    config?: LinterRuleConfigMeta;
}
/**
 * Represents what events a linter rule can handle
 */
interface LinterRuleEvents<StorageType = LinterRuleStorage<unknown>, ConfigType = unknown> {
    /**
     * Called before analyzing a filter list (before any rule is analyzed).
     * You can retrieve the filter list and other necessary information from the context.
     *
     * @param context - Linter context
     */
    onStartFilterList?: (context: GenericRuleContext<StorageType, ConfigType>) => void;
    /**
     * Called after analyzing a filter list (after all rules are analyzed).
     * You can retrieve the filter list and other necessary information from the context.
     *
     * @param context - Linter context
     */
    onEndFilterList?: (context: GenericRuleContext<StorageType, ConfigType>) => void;
    /**
     * Called when analyzing an adblock rule. This event is called for each rule, including comments.
     * You can retrieve the adblock rule and other necessary information from the context.
     *
     * @param context - Linter context
     */
    onRule?: (context: SpecificRuleContext<StorageType, ConfigType>) => void;
}
/**
 * Represents an AGLint rule
 */
interface LinterRule<StorageType = LinterRuleStorage<unknown>, ConfigType = unknown> {
    /**
     * Basic data of the rule (metadata)
     */
    meta: LinterRuleMeta;
    /**
     * Events belonging to the rule
     */
    events: LinterRuleEvents<StorageType, ConfigType>;
}
/**
 * Represents the core linter configuration
 */
interface LinterConfig {
    /**
     * Root configuration flag. If it's value is true, the configuration is root configuration.
     */
    root?: boolean;
    /**
     * Whether to allow inline configuration or not
     *
     * @example
     * ```adblock
     * ! aglint-disable-next-line
     * ```
     */
    allowInlineConfig?: boolean;
    /**
     * An array of configuration presets to extend
     */
    extends?: string[];
    /**
     * Specific adblock syntaxes to use for network rule modifiers validation.
     * Array of strings:
     * - `['Common']` (default)
     * - or any combination of `['AdGuard', 'uBlockOrigin', 'AdblockPlus']`.
     *
     * Can be set in the configuration file
     * or in the filter list as `Agent` type comment.
     *
     */
    syntax: AdblockSyntax[];
    /**
     * A map of rule names to their configuration
     */
    rules?: LinterRuleConfigObject;
}
/**
 * Represents a linter context that is passed to the rules when their events are triggered
 */
interface GenericRuleContext<StorageType = LinterRuleStorage<unknown>, ConfigType = unknown> {
    /**
     * Returns the clone of the shared linter configuration.
     *
     * @returns The shared linter configuration
     */
    getLinterConfig: () => LinterConfig;
    /**
     * Returns the raw content of the adblock filter list currently processed by the linter.
     *
     * @returns The raw adblock filter list content
     */
    getFilterListContent: () => string;
    /**
     * Returns whether a fix was requested from the linter. This is an optimization
     * for the linter, so it doesn't have to run the fixer if it's not needed.
     *
     * @returns `true` if fix is needed, `false` otherwise
     */
    fixingEnabled: () => boolean;
    /**
     * Storage for storing data between events. This storage is only visible to the rule.
     */
    storage: StorageType;
    /**
     * Additional config for the rule. This is unknown at this point, but the concrete
     * type is defined by the rule.
     */
    config: ConfigType;
    /**
     * Function for reporting problems to the linter.
     *
     * @param problem - The problem to report
     */
    report: (problem: LinterProblemReport) => void;
}
/**
 * Specialized linter context for the rule that is triggered when analyzing an adblock rule
 */
interface SpecificRuleContext<StorageType = LinterRuleStorage<unknown>, ConfigType = unknown> extends GenericRuleContext<StorageType, ConfigType> {
    /**
     * Returns the AST of the adblock rule currently being iterated by the linter.
     *
     * @returns The actual adblock rule as AST
     */
    getActualAdblockRuleAst: () => AnyRule;
    /**
     * Returns the raw version of the adblock rule currently being iterated by the linter.
     *
     * @returns The actual adblock rule as original string
     */
    getActualAdblockRuleRaw: () => string;
    /**
     * Returns the line number that the linter is currently iterating.
     *
     * @returns The actual line number
     */
    getActualLine: () => number;
}
/**
 * Represents the location of a problem that detected by the linter
 */
interface LinterPosition {
    /**
     * 1-based line number of the problem
     */
    startLine: number;
    /**
     * 0-based column number of the problem
     */
    startColumn: number;
    /**
     * 1-based line number of the problem
     */
    endLine: number;
    /**
     * 0-based column number of the problem
     */
    endColumn: number;
}
/**
 * Represents a problem report (this must be passed to context.report from the rules)
 */
interface LinterProblemReport {
    /**
     * Text description of the problem
     */
    message: string;
    /**
     * Node that caused the problem
     */
    node?: Node;
    /**
     * The location of the problem
     */
    position?: LinterPosition;
    /**
     * Suggested fix for the problem
     */
    fix?: AnyRule | AnyRule[];
    /**
     * Severity of the problem, overrides the rule severity set in the meta property.
     * Needed for modifiers validation, e.g. deprecated modifiers which are still supported
     * but will not be supported in the future, so they are not recommended to use.
     */
    customSeverity?: AnySeverity;
}
/**
 * Represents a linter rule storage object that is passed as reference to
 * the rules when their events are triggered.
 *
 * Basically used internally by the linter, so no need to export this.
 */
interface LinterRuleStorage<T = unknown> {
    [key: string]: T;
}

/**
 * @file AGLint core
 */

/**
 * Represents a linter result that is returned by the `lint` method
 */
interface LinterResult {
    /**
     * Array of problems detected by the linter
     */
    problems: LinterProblem[];
    /**
     * Count of warnings (just for convenience, can be calculated from problems array)
     */
    warningCount: number;
    /**
     * Count of errors (just for convenience, can be calculated from problems array)
     */
    errorCount: number;
    /**
     * Count of fatal errors (just for convenience, can be calculated from problems array)
     */
    fatalErrorCount: number;
    /**
     * The fixed filter list content. This is only available if the `fix` option is set to `true`.
     */
    fixed?: string;
}
/**
 * Represents a problem given by the linter
 */
interface LinterProblem {
    /**
     * Name of the linter rule that generated this problem
     */
    rule?: string;
    /**
     * The severity of this problem (it practically inherits the rule severity)
     */
    severity: AnySeverity;
    /**
     * Text description of the problem
     */
    message: string;
    /**
     * The location of the problem
     */
    position: LinterPosition;
    /**
     * Suggested fix for the problem (if available)
     */
    fix?: AnyRule | AnyRule[];
}
/**
 * Represents a linter rule data object. Basically used internally by the linter,
 * so no need to export this.
 */
interface LinterRuleData {
    /**
     * The linter rule itself. It's meta provides the rule severity and default config,
     * which can be overridden by the user here.
     */
    rule: AnyLinterRule;
    /**
     * Storage for storing data between events. This storage is only visible
     * to the rule.
     */
    storage: LinterRuleStorage;
    /**
     * Custom config for the rule (it overrides the default config if provided)
     */
    configOverride?: unknown;
    /**
     * Custom severity for the rule (it overrides the default severity if provided)
     */
    severityOverride?: AnySeverity;
}
/**
 * Core linter logic
 */
declare class Linter {
    /**
     * A map of rule names to `LinterRule` objects
     */
    private readonly rules;
    /**
     * The linter configuration
     */
    private config;
    /**
     * Config presets
     */
    private configPresets;
    /**
     * Creates a new linter instance.
     *
     * @param defaultRules Add default linter rules and config presets to the linter
     * (by default it adds them)
     * @param config Linter config to use (by default it uses the default config)
     */
    constructor(defaultRules?: boolean, config?: LinterConfig);
    /**
     * Adds all default rules to the linter.
     */
    addDefaultRules(): void;
    /**
     * Adds all default config presets to the linter.
     */
    addDefaultConfigPresets(): void;
    /**
     * Sets the config for a given rule. It just overrides the default config.
     *
     * @param ruleName The name of the rule to set the config for
     * @param ruleConfig The config to set
     * @throws If the rule doesn't exist
     * @throws If the rule severity / config is invalid
     * @throws If the rule doesn't support config
     */
    setRuleConfig(ruleName: string, ruleConfig: LinterRuleConfig): void;
    /**
     * This method applies the configuration "rules" part to the linter.
     *
     * @param rulesConfig Rules config object
     */
    applyRulesConfig(rulesConfig: LinterRuleConfigObject): void;
    /**
     * Gets the linter configuration.
     *
     * @returns The linter configuration
     */
    getConfig(): LinterConfig;
    /**
     * Adds a new config preset to the linter.
     *
     * @param name Config preset name, e.g. "aglint:recommended"
     * @param config Related config object
     * @throws If the config preset already exists
     */
    addConfigPreset(name: string, config: LinterConfig): void;
    /**
     * Applies the config presets to the config object (extends the config
     * with the given presets if they exist).
     *
     * @param config Config object
     * @returns Extended config object
     * @throws If the config preset doesn't exist
     * @throws If the config is invalid
     */
    applyConfigExtensions(config: LinterConfig): LinterConfig;
    /**
     * Sets the linter configuration. If `reset` is set to `true`, all rule
     * configurations are reset to their default values (removing overrides).
     *
     * @param config Core linter configuration
     * @param reset Whether to reset all rule configs
     * @throws If any of the config presets doesn't exist
     * @throws If the rule config is invalid in any way
     */
    setConfig(config: LinterConfig, reset?: boolean): void;
    /**
     * Adds a new rule to the linter.
     *
     * @param name The name of the rule
     * @param rule The rule itself
     * @throws If the rule name is already taken
     */
    addRule(name: string, rule: AnyLinterRule): void;
    /**
     * Adds a new rule to the linter, but you can specify the rule data.
     *
     * @param name The name of the rule
     * @param data The rule data, see `LinterRuleData` interface for more details
     * @throws If the rule name is already taken
     * @throws If the rule severity is invalid
     * @throws If the rule config is invalid
     */
    addRuleEx(name: string, data: LinterRuleData): void;
    /**
     * Resets default config for the rule with the specified name.
     *
     * @param name The name of the rule
     * @throws If the rule doesn't exist
     * @throws If the rule doesn't support config
     */
    resetRuleConfig(name: string): void;
    /**
     * Gets the current config for the rule with the specified name.
     *
     * @param name The name of the rule
     * @returns The currently active config for the rule. If no override is set,
     * the default config is returned.
     * @throws If the rule doesn't exist
     * @throws If the rule doesn't support config
     */
    getRuleConfig(name: string): LinterRuleConfig;
    /**
     * Returns the `LinterRule` object with the specified name.
     *
     * @param name - The name of the rule
     * @returns The `LinterRule` object, or `undefined` if no such rule exists
     */
    getRule(name: string): AnyLinterRule | undefined;
    /**
     * Returns the map of all rules in the repository.
     *
     * @returns The map of rule names to `LinterRule` objects
     */
    getRules(): Map<string, LinterRuleData>;
    /**
     * Returns whether a rule with the specified name exists in the repository.
     *
     * @param name - The name of the rule
     * @returns `true` if the rule exists, `false` otherwise
     */
    hasRule(name: string): boolean;
    /**
     * Removes a rule from the repository.
     *
     * @param name - The name of the rule
     */
    removeRule(name: string): void;
    /**
     * Disables a rule by name.
     *
     * @param name - The name of the rule
     * @throws If the rule does not exist
     */
    disableRule(name: string): void;
    /**
     * Enables a rule
     *
     * @param name - The name of the rule
     * @throws If the rule does not exist
     */
    enableRule(name: string): void;
    /**
     * Returns whether a rule is disabled.
     *
     * @param name - The name of the rule
     * @returns `true` if the rule is disabled, `false` otherwise
     */
    isRuleDisabled(name: string): boolean;
    /**
     * Lints the list of rules (typically this is the content of a filter list).
     *
     * @param content - Filter list content
     * @param fix - Include fixes in the result. Please note that if more than one fix
     * is available for a single problem, then the line will be skipped.
     * @returns Linter result
     */
    lint(content: string, fix?: boolean): LinterResult;
}

/**
 * @file AGLint version
 */
declare const version: string;

/**
 * Represents a reporter skeleton for the linter.
 */
interface LinterCliReporter {
    /**
     * Called when the whole linting process starts.
     */
    onLintStart?: () => void;
    /**
     * Called when linting a file starts.
     *
     * @param file The file that is being linted
     * @param config The linter configuration
     */
    onFileStart?: (file: ParsedPath, config: LinterConfig) => void;
    /**
     * Called when linting a file ends. It will give you the result of the linting
     * and the configuration that was used (if you want to do something with it).
     *
     * @param file The file that was linted
     * @param result The result of the linting
     * @param config The linter configuration
     */
    onFileEnd?: (file: ParsedPath, result: LinterResult, config: LinterConfig) => void;
    /**
     * Called when the whole linting process ends.
     */
    onLintEnd?: () => void;
}

/**
 * Implements CLI functionality for the linter. Typically used by the `aglint` command in Node.js environment.
 */
declare class LinterCli {
    /**
     * The reporter to be used for the CLI.
     */
    private readonly reporter;
    private fix;
    private ignore;
    private errors;
    /**
     * Creates a new `LinterCli` instance.
     *
     * @param reporter The reporter to be used for the CLI
     * @param fix Fix fixable problems automatically
     * @param ignore Use `.aglintignore` files
     */
    constructor(reporter: LinterCliReporter, fix?: boolean, ignore?: boolean);
    /**
     * Lints a file with the given config. Also compatible with the `WalkEvent` type,
     * so it can be used with the `walk` function.
     *
     * @param file The file to be linted
     * @param config The active linter config (merged from parent directories)
     */
    private lintFile;
    /**
     * Returns true if the linter found any errors.
     *
     * @returns `true` if the linter found any errors, `false` otherwise
     */
    hasErrors: () => boolean;
    /**
     * Lints the current working directory. If you specify files, it will only lint those files.
     *
     * @param cwd The current working directory
     * @param files The files to be linted (if not specified, it will scan the cwd)
     */
    run: (cwd: string, files?: string[]) => Promise<void>;
}

/**
 * Reads and parses supported configuration files.
 *
 * @param filePath - The name of the configuration file to be read and parsed.
 * @returns The parsed config object.
 * @throws If the file not found or the file extension is not supported.
 * @throws If the file contents are not valid JSON or YAML.
 * @throws If the file contents are not valid according to the config schema.
 */
declare function parseConfigFile(filePath: string): Promise<LinterConfig>;

/**
 * Implements a simple reporter that logs the problems to the console.
 * You can implement any reporter you want, as long as it implements the
 * `LinterCliReporter` interface.
 */
declare class LinterConsoleReporter implements LinterCliReporter {
    /**
     * We save the start time here, so we can calculate the total time at the end.
     */
    private startTime;
    /**
     * Custom Chalk instance to use for coloring the console output.
     */
    private chalk;
    /**
     * Total number of warnings
     */
    private warnings;
    /**
     * Total number of errors
     */
    private errors;
    /**
     * Total number of fatal errors
     */
    private fatals;
    /**
     * Creates a new console reporter instance.
     *
     * @param colors Whether to use colors in the console output or not
     */
    constructor(colors?: boolean);
    /**
     * Collected problems, where the key is the file path and the value is an array of problems.
     * We only collect problems here, we don't log them, because we want to log them in the end.
     */
    private problems;
    onLintStart: () => void;
    onFileStart: (file: ParsedPath) => void;
    onFileEnd: (file: ParsedPath, result: LinterResult) => void;
    onLintEnd: () => void;
}

/**
 * Represents the result of a scan
 */
interface ScannedDirectory {
    /**
     * Data about the current directory
     */
    dir: ParsedPath;
    /**
     * Only one config file is allowed in a directory, it may be null if no config file is found in
     * the directory
     */
    configFile: ParsedPath | null;
    /**
     * Lintable files in the directory (if any)
     */
    lintableFiles: ParsedPath[];
    /**
     * Subdirectories in the directory (if any)
     */
    subdirectories: ScannedDirectory[];
}
/**
 * Searches for lintable files in a directory recursively. Practically it means files with the
 * supported extensions. It will also search for config files.
 *
 * It will ignore files and directories that are ignored by the ignore file at any level.
 * `.aglintignore` works exactly like `.gitignore`.
 *
 * @param dir Directory to search in
 * @param ignores File ignores
 * @param useIgnoreFiles Use ignore files or not (default: true)
 * @returns The result of the scan (`ScannedDirectory` object)
 * @throws If multiple config files are found in the given directory
 */
declare function scan(dir: string, ignores?: Ignore[], useIgnoreFiles?: boolean): Promise<ScannedDirectory>;

/**
 * An event that is performed on a file or directory.
 *
 * @param path The path of the file or directory
 * @param config The active linter config
 * @param fix Fix fixable problems automatically
 */
type WalkEvent = (path: ParsedPath, config: LinterConfig, fix: boolean) => Promise<void>;
/**
 * An object containing the events to be performed on each file and directory.
 */
interface WalkEvents {
    file: WalkEvent;
    dir?: WalkEvent;
}
/**
 * Walks a `ScannedDirectory` object and performs an action on each file and directory
 * in the tree.
 *
 * @param scannedDirectory The `ScannedDirectory` object to be walked
 * @param events The events to be performed on each file and directory
 * @param config The CLI config
 * @param fix Fix fixable problems automatically
 */
declare function walk(scannedDirectory: ScannedDirectory, events: WalkEvents, config: LinterConfig, fix?: boolean): Promise<void>;

/**
 * Constructs a config object for the given directory by merging all config files
 * from the root config file to the actual directory. It searches all config files
 * in the upper directories until it finds a root config file or the actual directory
 * is the root directory, then it merges the config files from the root directory
 * to the actual directory after each other. This will results the corresponding
 * config object for the given directory. Works same as ESLint.
 *
 * @param dir Base directory
 * @returns Config object
 * @throws If no config file was found
 * @throws If a config file is found, but it is not valid
 * @throws If multiple config files are found in the same directory
 */
declare function buildConfigForDirectory(dir: string): Promise<LinterConfig>;

/**
 * Callback for the config finder, called when a potential config file is found.
 * If you want to stop the search, return `true` from the callback, otherwise
 * return `false`.
 *
 * @param path Path to the config file
 * @returns `true` if the search should be stopped, `false` otherwise
 */
type ConfigFinderCallback = (path: string) => boolean | Promise<boolean>;
/**
 * Result of the config finder
 */
type ConfigFinderResult = {
    /**
     * Path to the config file
     */
    path: string;
    /**
     * Parsed config object
     */
    config: LinterConfig;
};
/**
 * Discovers every AGLint config files in the current working directory and its parent directories.
 * It only checks file names, not the contents of the files, so it doesn't validate the config files.
 * If you didn't abort the search meanwhile, it will scan until it reaches the root directory.
 *
 * @param cwd Current working directory
 * @param callback Callback function that will be called with the path to the config file
 * if it is found
 * @throws If multiple config files are found in the same directory
 */
declare function configFinder(cwd: string, callback: ConfigFinderCallback): Promise<void>;
/**
 * Finds the next config file in the current working directory and its parent directories.
 * It just searches for the first config file and returns its path.
 *
 * @param cwd Current working directory
 * @throws If multiple config files are found in the same directory
 * @throws If a config file is found, but it is not valid
 * @returns The path to the config file and the parsed config object or `null` if no config file was found
 */
declare function findNextConfig(cwd: string): Promise<ConfigFinderResult | null>;
/**
 * Finds the first root config file in the current working directory and its parent directories.
 * It parses the config files and stops the search when it finds the root config file, which
 * is the first config file that has the "root" property set to `true`.
 *
 * If it doesn't find a root config file, but it finds a config file, it will return the first
 * config file.
 *
 * @param cwd Current working directory
 * @throws If multiple config files are found in the same directory
 * @throws If a config file is found, but it is not valid
 * @returns The path to the config file and the parsed config object or `null` if no config file was found
 */
declare function findNextRootConfig(cwd: string): Promise<ConfigFinderResult | null>;

/**
 * We throw this error when we can't find a config file for the given directory.
 * It is easy to catch this error and show a nice error message to the user
 * when using the CLI tool.
 */
declare class NoConfigError extends Error {
    constructor(dir: string);
}

export { ConfigFinderCallback, ConfigFinderResult, GenericRuleContext, Linter, LinterCli, LinterCliReporter, LinterConfig, LinterConsoleReporter, LinterPosition, LinterProblem, LinterProblemReport, LinterResult, LinterRule, LinterRuleConfigArray, LinterRuleConfigMeta, LinterRuleConfigObject, LinterRuleData, LinterRuleEvents, LinterRuleMeta, LinterRuleStorage, NoConfigError, ScannedDirectory, WalkEvent, buildConfigForDirectory, configFinder, findNextConfig, findNextRootConfig, parseConfigFile, scan, version, walk };
