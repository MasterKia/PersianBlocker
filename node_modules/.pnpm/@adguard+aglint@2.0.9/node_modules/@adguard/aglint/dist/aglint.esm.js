/*
 * AGLint v2.0.9 (build date: Thu, 25 Apr 2024 09:15:58 GMT)
 * (c) 2024 AdGuard Software Ltd.
 * Released under the MIT license
 * https://github.com/AdguardTeam/AGLint#readme
 */
import { define, union, is, optional, record, string, boolean, array, enums, object, number, assert, StructError } from 'superstruct';
import cloneDeep from 'clone-deep';
import { DomainUtils, modifierValidator, FilterListParser } from '@adguard/agtree';
import merge from 'deepmerge';
import equal from 'fast-deep-equal';
import path, { parse, resolve, join } from 'node:path';
import { readFile, readdir, stat, writeFile } from 'node:fs/promises';
import { pathExists } from 'fs-extra';
import yaml from 'js-yaml';
import ignore from 'ignore';
import chalk from 'chalk';
import terminalLink from 'terminal-link';
import stripAnsi from 'strip-ansi';
import table from 'text-table';
import { inflect } from 'inflection';

/**
 * Represents the possible severities of a linter rule
 */
const SEVERITY = Object.freeze({
    /**
     * Rule is disabled, nothing happens
     */
    off: 0,
    /**
     * Rule is enabled, and throws a warning when violated.
     *
     * @example Bad practices, deprecated syntax, formatting issues, redundant rules, etc.
     */
    warn: 1,
    /**
     * Rule is enabled, and throws an error when violated.
     *
     * @example Unknown scriptlets, unknown modifiers, etc.
     */
    error: 2,
    /**
     * Rule is enabled, and throws a fatal error when violated.
     *
     * @example Syntax error (parsing error)
     */
    fatal: 3,
});
/**
 * Names of the possible severities
 */
const SEVERITY_NAMES = Object.freeze(Object.keys(SEVERITY));
/**
 * Values of the possible severities
 */
const SEVERITY_VALUES = Object.freeze(Object.values(SEVERITY));
/**
 * Always returns the severity value. Typically used to get the severity value from a string.
 *
 * @param value The value to get the severity value from
 * @returns The severity value
 */
function getSeverity(value) {
    if (typeof value === 'string') {
        return SEVERITY[value];
    }
    return value;
}
/**
 * Checks whether the given value is a valid severity
 *
 * @param value The value to check
 * @returns Whether the value is a valid severity
 */
function isSeverity(value) {
    if (typeof value === 'string') {
        return SEVERITY_NAMES.includes(value);
    }
    if (typeof value === 'number') {
        return SEVERITY_VALUES.includes(value);
    }
    return false;
}
/**
 * Superstruct type definition for the linter rule severity
 *
 * @returns Defined struct
 * @see {@link https://github.com/ianstormtaylor/superstruct/blob/main/src/structs/types.ts}
 */
function severity() {
    // TODO: Fix possible type error
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore 2322
    return define('severity', (value) => {
        if (typeof value === 'string') {
            return (SEVERITY_NAMES.includes(value)
                || `Expected a valid severity string (${SEVERITY_NAMES.join(', ')}), but received ${value}`);
        }
        if (typeof value === 'number') {
            return (SEVERITY_VALUES.includes(value)
                || `Expected a valid severity number, but received ${value}`);
        }
        return `Expected a string or number, but received ${typeof value}`;
    });
}

/**
 * Own Superstruct type definition for the linter rule config array
 *
 * @returns Defined struct
 * @see {@link https://github.com/ianstormtaylor/superstruct/blob/main/src/structs/types.ts}
 */
function configArray() {
    return define('configArray', (value) => {
        if (Array.isArray(value)) {
            // First element should be severity, the rest can be anything,
            // we don't know anything about them at this point
            if (is(value[0], severity())) {
                return true;
            }
            return `Expected a severity as first element, but received ${typeof value[0]}`;
        }
        return `Expected an array, but received ${typeof value}`;
    });
}
/**
 * Superstruct schema for the linter rule config (used for validation)
 *
 * Possible values:
 * - severity itself (number or string): `severity`
 * - one-element array with severity as the first element: `[severity]`
 * - n-element array with severity as the first element and other options as the rest: `[severity, ...options]`
 */
const linterRuleConfigSchema = union([severity(), configArray()]);

/**
 * Linter configuration
 */
/**
 * Superstruct schema for the linter rules config object
 */
const linterRulesSchema = optional(record(string(), linterRuleConfigSchema));
/**
 * Superstruct schema for the linter config object properties. It is necessary to
 * separate this from the schema for the whole config object because we reuse it
 * in the CLI config object.
 */
const linterConfigPropsSchema = {
    root: optional(boolean()),
    extends: optional(array(string())),
    allowInlineConfig: optional(boolean()),
    syntax: optional(array(enums([
        "Common" /* AdblockSyntax.Common */,
        "AdGuard" /* AdblockSyntax.Adg */,
        "UblockOrigin" /* AdblockSyntax.Ubo */,
        "AdblockPlus" /* AdblockSyntax.Abp */,
    ]))),
    rules: linterRulesSchema,
};
/**
 * Superstruct schema for the linter rule config (used for validation)
 */
const linterConfigSchema = object(linterConfigPropsSchema);
/**
 * Default linter configuration
 */
const defaultLinterConfig = {
    allowInlineConfig: true,
    syntax: ["Common" /* AdblockSyntax.Common */],
};
/**
 * Merges two configuration objects using deepmerge. Practically, this means that
 * the `extend` object will be merged into the `initial` object.
 *
 * @param initial The initial config object
 * @param extend The config object to extend the initial config with
 * @returns The merged config object
 * @example
 * If you have the following config (called `initial` parameter):
 * ```json
 * {
 *   "syntax": ["Common"],
 *   "rules": {
 *     "rule1": "error",
 *     "rule2": "warn"
 *   }
 * }
 * ```
 * And you want to extend it with the following config (called `extend` parameter):
 * ```json
 * {
 *   "syntax": ["AdGuard"],
 *   "rules": {
 *     "rule2": "off",
 *   },
 * }
 * ```
 * The result will be:
 * ```json
 * {
 *   "syntax": ["AdGuard"],
 *   "rules": {
 *     "rule1": "error",
 *     "rule2": "off"
 *   }
 * }
 * ```
 */
function mergeConfigs(initial, extend) {
    return merge(initial, extend, {
        // https://github.com/TehShrike/deepmerge#options
        arrayMerge: (_, sourceArray) => sourceArray,
    });
}
/**
 * Merges two configuration objects using deepmerge.merge().
 * Practically, this means that the `extend` object will be merged into the `initial` object.
 *
 * It is very similar to {@link mergeConfigs|mergeConfigs()} function, but the order of parameters is reversed.
 *
 * @param extend The config object to extend the initial config with
 * @param initial The initial config object
 * @returns The merged config object
 */
function mergeConfigsReverse(extend, initial) {
    return merge(extend, initial, {
        // https://github.com/TehShrike/deepmerge#options
        arrayMerge: (_, sourceArray) => sourceArray,
    });
}

const PLATFORM$2 = 'PLATFORM';
const NOT_PLATFORM$2 = 'NOT_PLATFORM';
/**
 * Rule that checks if a platform is used more than once within the same PLATFORM / NOT_PLATFORM hint.
 */
const DuplicatedHintPlatforms = {
    meta: {
        severity: SEVERITY.warn,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "HintCommentRule" /* CommentRuleType.HintCommentRule */) {
                // Iterate over all hints within the comment rule
                for (const hint of ast.children) {
                    const name = hint.name.value;
                    // Only makes sense to check this, if the hint is a PLATFORM or NOT_PLATFORM hint
                    // and there are at least two platforms within the hint
                    if ((name !== PLATFORM$2 && name !== NOT_PLATFORM$2)
                        || !hint.params || hint.params.children.length < 2) {
                        continue;
                    }
                    // Store which platforms are already present
                    const occurred = new Set();
                    // Iterate over all platforms within the hint
                    for (const param of hint.params.children) {
                        const platform = param.value;
                        const platformToLowerCase = platform.toLowerCase();
                        if (!occurred.has(platformToLowerCase)) {
                            occurred.add(platformToLowerCase);
                        }
                        else {
                            // Report if a platform is occurring more than once
                            context.report({
                                // eslint-disable-next-line max-len
                                message: `The platform "${platform}" is occurring more than once within the same "${hint.name.value}" hint`,
                                node: param,
                            });
                        }
                    }
                }
            }
        },
    },
};

/**
 * Rule that checks if hints are duplicated within the same comment rule.
 */
const DuplicatedHints = {
    meta: {
        severity: SEVERITY.warn,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "HintCommentRule" /* CommentRuleType.HintCommentRule */) {
                // Only makes sense to check this, if there are at least two hints within the comment
                if (ast.children.length < 2) {
                    return;
                }
                // Store which hints are already present
                const occurred = new Set();
                // Iterate over all hints within the comment rule
                for (const hint of ast.children) {
                    const name = hint.name.value;
                    const nameToLowerCase = name.toLowerCase();
                    if (!occurred.has(nameToLowerCase)) {
                        occurred.add(nameToLowerCase);
                    }
                    else {
                        // Report if a hint is occurring more than once
                        context.report({
                            message: `The hint "${name}" is occurring more than once within the same comment rule`,
                            node: hint,
                        });
                    }
                }
            }
        },
    },
};

const NOT_OPTIMIZED = 'NOT_OPTIMIZED';
const PLATFORM$1 = 'PLATFORM';
const NOT_PLATFORM$1 = 'NOT_PLATFORM';
// https://adguard.com/kb/general/ad-filtering/create-own-filters/#hints
const KNOWN_HINTS = new Set([
    NOT_OPTIMIZED,
    PLATFORM$1,
    NOT_PLATFORM$1,
]);
// https://adguard.com/kb/general/ad-filtering/create-own-filters/#platform-and-not_platform-hints
const KNOWN_PLATFORMS = new Set([
    'windows',
    'mac',
    'android',
    'ios',
    'ext_chromium',
    'ext_ff',
    'ext_edge',
    'ext_opera',
    'ext_safari',
    'ext_android_cb',
    'ext_ublock',
]);
/**
 * Rule that checks if hints and platforms are known.
 */
const UnknownHintsAndPlatforms = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "HintCommentRule" /* CommentRuleType.HintCommentRule */) {
                for (const hint of ast.children) {
                    // Check if the hint name is known (case-sensitive)
                    if (!KNOWN_HINTS.has(hint.name.value)) {
                        context.report({
                            message: `Unknown hint name "${hint.name.value}"`,
                            node: hint.name,
                        });
                    }
                    else if (hint.name.value === PLATFORM$1 || hint.name.value === NOT_PLATFORM$1) {
                        if (!hint.params || hint.params.children.length === 0) {
                            context.report({
                                message: `Hint "${hint.name.value}" must have at least one platform specified`,
                                node: hint,
                            });
                        }
                        else {
                            for (const param of hint.params.children) {
                                // Check if the platform is known (case sensitive)
                                if (!KNOWN_PLATFORMS.has(param.value)) {
                                    context.report({
                                        message: `Unknown platform "${param.value}" in hint "${hint.name.value}"`,
                                        node: param,
                                    });
                                }
                            }
                        }
                    }
                    else if (hint.name.value === NOT_OPTIMIZED) {
                        // If the hint has any parameters, it's invalid, including "NOT_OPTIMIZED()"
                        if (hint.params) {
                            context.report({
                                message: `Hint "${hint.name.value}" must not have any parameters`,
                                node: hint,
                            });
                        }
                    }
                }
            }
        },
    },
};

/**
 * Rule that checks if a network rule contains multiple same modifiers
 */
const DuplicatedModifiers = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            // Check if the rule is a basic network rule
            if (ast.category === "Network" /* RuleCategory.Network */ && ast.type === 'NetworkRule') {
                // Store which modifiers are already present
                const occurred = new Set();
                // This check is only relevant if there are at least two modifiers
                if (!ast.modifiers || ast.modifiers.children.length < 2) {
                    return;
                }
                for (const modifier of ast.modifiers.children) {
                    const name = modifier.modifier.value;
                    const nameToLowerCase = name.toLowerCase();
                    if (!occurred.has(nameToLowerCase)) {
                        occurred.add(nameToLowerCase);
                    }
                    else {
                        // Report if a modifier is occurring more than once
                        context.report({
                            message: `The modifier "${name}" is used multiple times, but it should be used only once`,
                            node: modifier,
                        });
                    }
                }
            }
        },
    },
};

/**
 * @file Constant values used by all parts of the library
 */
const REPO_URL = 'https://github.com/AdguardTeam/AGLint';
// General
const EMPTY = '';
const SPACE = ' ';
const COMMA = ',';
const DOT = '.';
const HASHMARK = '#';
const LF = '\n';
const DOUBLE_NEWLINE = '\n\n';
const NEWLINE = LF;
// Brackets
const OPEN_PARENTHESIS = '(';
const CLOSE_PARENTHESIS = ')';
const IF_DIRECTIVE = 'if';
const ELSE_DIRECTIVE = 'else';
const ENDIF_DIRECTIVE = 'endif';
const INCLUDE_DIRECTIVE = 'include';
const SAFARI_CB_AFFINITY_DIRECTIVE = 'safari_cb_affinity';
const SUPPORTED_PREPROCESSOR_DIRECTIVES = new Set([
    ELSE_DIRECTIVE,
    ENDIF_DIRECTIVE,
    IF_DIRECTIVE,
    INCLUDE_DIRECTIVE,
    SAFARI_CB_AFFINITY_DIRECTIVE,
]);

/**
 * Rule that checks if all if directives are closed
 */
const IfClosed = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onStartFilterList: (context) => {
            // Each rule ONLY sees its own storage. At the beginning of the filter list,
            // we just initialize the storage.
            context.storage.openIfs = [];
        },
        onRule: (context) => {
            // Get actually iterated adblock rule
            const rule = context.getActualAdblockRuleAst();
            // Check adblock rule category and type
            if (rule.category !== "Comment" /* RuleCategory.Comment */
                || rule.type !== "PreProcessorCommentRule" /* CommentRuleType.PreProcessorCommentRule */) {
                return;
            }
            const directive = rule.name.value;
            switch (directive) {
                case IF_DIRECTIVE:
                    // Collect open "if"
                    context.storage.openIfs.push(rule);
                    break;
                case ELSE_DIRECTIVE:
                    // '!#else' can only be used alone without any parameters
                    if (rule.params) {
                        context.report({
                            message: `Invalid usage of preprocessor directive: "${ELSE_DIRECTIVE}"`,
                            node: rule,
                        });
                    }
                    // Check if there is an open "!#if" before "!#else"
                    if (context.storage.openIfs.length === 0) {
                        context.report({
                            // eslint-disable-next-line max-len
                            message: `Using an "${ELSE_DIRECTIVE}" directive without an opening "${IF_DIRECTIVE}" directive`,
                            node: rule,
                        });
                    }
                    // otherwise do nothing
                    break;
                case ENDIF_DIRECTIVE:
                    // '!#endif' can only be used alone without any parameters
                    if (rule.params) {
                        context.report({
                            message: `Invalid usage of preprocessor directive: "${ENDIF_DIRECTIVE}"`,
                            node: rule,
                        });
                    }
                    if (context.storage.openIfs.length === 0) {
                        context.report({
                            // eslint-disable-next-line max-len
                            message: `Using an "${ENDIF_DIRECTIVE}" directive without an opening "${IF_DIRECTIVE}" directive`,
                            node: rule,
                        });
                    }
                    else {
                        // Mark "if" as closed (simply delete it from collection)
                        context.storage.openIfs.pop();
                    }
                    break;
            }
        },
        onEndFilterList: (context) => {
            // If there are any collected "if"s, that means they aren't closed, so a problem must be reported for them
            for (const rule of context.storage.openIfs) {
                context.report({
                    message: `Unclosed "${IF_DIRECTIVE}" directive`,
                    node: rule,
                });
            }
        },
    },
};

/**
 * Rule that checks validity of domains in cosmetic rules
 */
const InvalidDomainList = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            // Check if the rule is a cosmetic rule (any cosmetic rule)
            if (ast.category === "Cosmetic" /* RuleCategory.Cosmetic */) {
                // Iterate over all domains within the rule
                for (const node of ast.domains.children) {
                    // If the domain is invalid, report it
                    if (!DomainUtils.isValidDomainOrHostname(node.value)) {
                        context.report({
                            message: `Invalid domain "${node.value}"`,
                            node,
                        });
                    }
                }
            }
        },
    },
};

/**
 * Rule that checks modifiers validity for basic (network) rules
 */
const InvalidModifiers = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            if (ast.category === "Network" /* RuleCategory.Network */) {
                // get lint of syntaxes to validate modifiers for
                const validateSyntax = context.getLinterConfig().syntax;
                // validate modifiers for every syntax and collect problems if any
                validateSyntax.forEach((agent) => {
                    if (!ast.modifiers) {
                        return;
                    }
                    ast.modifiers.children.forEach((modifier) => {
                        const validationResult = modifierValidator.validate(agent, modifier, ast.exception);
                        if (validationResult.valid
                            && !validationResult.warn) {
                            return;
                        }
                        // default invalid modifier message
                        let message = `Invalid modifier: '${modifier.value}'`;
                        // needed for deprecated modifiers which are valid but not recommended
                        // so should be just _warned_ about
                        let customSeverity;
                        if (validationResult.warn) {
                            message = validationResult.warn;
                            customSeverity = SEVERITY.warn;
                        }
                        if (validationResult.error) {
                            message = validationResult.error;
                        }
                        context.report({
                            message,
                            node: modifier,
                            customSeverity,
                        });
                    });
                });
            }
        },
    },
};

const PLATFORM = 'PLATFORM';
const NOT_PLATFORM = 'NOT_PLATFORM';
/**
 * Rule that checks if a platform targeted by a PLATFORM() hint is also excluded by a NOT_PLATFORM()
 * hint at the same time.
 */
const InconsistentHintPlatforms = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "HintCommentRule" /* CommentRuleType.HintCommentRule */) {
                // Only makes sense to check this, if there are at least two hints within the comment
                if (ast.children.length < 2) {
                    return;
                }
                // Platforms targeted by a PLATFORM() hint
                const platforms = [];
                // Platforms excluded by a NOT_PLATFORM() hint
                const notPlatforms = [];
                // Iterate over all hints within the hint comment rule
                for (const hint of ast.children) {
                    for (const param of hint.params?.children ?? []) {
                        // Add actual platform (parameter) to the corresponding array
                        if (hint.name.value === PLATFORM) {
                            platforms.push(param);
                        }
                        else if (hint.name.value === NOT_PLATFORM) {
                            notPlatforms.push(param);
                        }
                    }
                }
                // Find platforms that are targeted by a PLATFORM() hint and excluded by a
                // NOT_PLATFORM() hint at the same time, but take duplicates into account
                const commonPlatforms = [];
                for (const platform of platforms) {
                    for (const notPlatform of notPlatforms) {
                        if (platform.value === notPlatform.value) {
                            // Check if the platform is already in the array (loc property is unique
                            // and definietly exists, since we configured the parser to do so)
                            if (!commonPlatforms.some((e) => equal(e.loc, platform.loc))) {
                                commonPlatforms.push(platform);
                            }
                            if (!commonPlatforms.some((e) => equal(e.loc, notPlatform.loc))) {
                                commonPlatforms.push(notPlatform);
                            }
                        }
                    }
                }
                // Sort platforms by their location (loc.start.offset) to get a consistent order
                // It is safe to use the non-null assertion operator here, because the loc property
                // is always defined for parameters, since we configured the parser to do so
                // eslint-disable-next-line max-len, @typescript-eslint/no-non-null-assertion
                const commonPlatformsOrdered = commonPlatforms.sort((a, b) => a.loc.start.offset - b.loc.start.offset);
                // Report all platforms that are targeted by a PLATFORM() hint and excluded by a
                // NOT_PLATFORM() hint at the same time
                for (const platform of commonPlatformsOrdered) {
                    context.report({
                        // eslint-disable-next-line max-len
                        message: `Platform "${platform.value}" is targeted by a PLATFORM() hint and excluded by a NOT_PLATFORM() hint at the same time`,
                        node: platform,
                    });
                }
            }
        },
    },
};

/**
 * Rule that checks if a cosmetic rule contains multiple selectors
 */
const SingleSelector = {
    meta: {
        severity: SEVERITY.warn,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            // Check if the rule is an element hiding rule
            if (ast.category === "Cosmetic" /* RuleCategory.Cosmetic */ && ast.type === "ElementHidingRule" /* CosmeticRuleType.ElementHidingRule */) {
                // Only makes sense to check this, if there are at least two selectors within the rule
                if (ast.body.selectorList.children.length < 2) {
                    return;
                }
                // Prepare the problem report
                const report = {
                    message: 'An element hiding rule should contain only one selector',
                    node: ast.body.selectorList,
                };
                // Suggest a fix for the problem if the user wants to fix the problem automatically
                if (context.fixingEnabled()) {
                    // Collect selectors into different rules (one selector per rule)
                    report.fix = [];
                    // Iterate over all selectors in the current rule
                    for (const selector of ast.body.selectorList.children) {
                        // Create a new rule with the same properties as the current rule.
                        const clone = cloneDeep(ast);
                        // Replace the selector list with a new selector list containing only
                        // the currently iterated selector
                        clone.body.selectorList.children = [selector];
                        // The only difference is that the new rule only contains one selector,
                        // which has the currently iterated selector in its body.
                        report.fix.push(clone);
                    }
                }
                // Report the problem to the linting context
                context.report(report);
            }
        },
    },
};

/**
 * Checks if a preprocessor directive is known
 *
 * @param name Preprocessor directive name to check
 * @returns `true` if the preprocessor directive is known, `false` otherwise
 */
function isKnownPreProcessorDirective(name) {
    return SUPPORTED_PREPROCESSOR_DIRECTIVES.has(name);
}
/**
 * Rule that checks if a preprocessor directive is known.
 *
 * Directives are case-sensitive, so `!#IF` is to be considered as invalid.
 */
const UnknownPreProcessorDirectives = {
    meta: {
        severity: SEVERITY.error,
    },
    events: {
        onRule: (context) => {
            // Get actually iterated adblock rule
            const ast = context.getActualAdblockRuleAst();
            // Check if the rule is a preprocessor comment
            if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "PreProcessorCommentRule" /* CommentRuleType.PreProcessorCommentRule */) {
                if (!isKnownPreProcessorDirective(ast.name.value)) {
                    context.report({
                        message: `Unknown preprocessor directive "${ast.name.value}"`,
                        node: ast.name,
                    });
                }
            }
        },
    },
};

const DEFAULT_MIN_RULE_LENGTH = 4;
/**
 * Rule that checks if a rule is too short
 */
const NoShortRules = {
    meta: {
        severity: SEVERITY.error,
        config: {
            default: {
                minLength: DEFAULT_MIN_RULE_LENGTH,
            },
            schema: object({
                minLength: number(),
            }),
        },
    },
    events: {
        onRule: (context) => {
            const minRuleLength = context.config.minLength ?? DEFAULT_MIN_RULE_LENGTH;
            const ruleText = context.getActualAdblockRuleRaw();
            const ruleTextTrimmed = ruleText.trim();
            const ruleNode = context.getActualAdblockRuleAst();
            if (
            // Ignore comment rules
            (ruleNode.category === "Cosmetic" /* RuleCategory.Cosmetic */ || ruleNode.category === "Network" /* RuleCategory.Network */)
                && ruleTextTrimmed.length < minRuleLength) {
                context.report({
                    message: `Too short rule: '${ruleText}'`,
                    node: ruleNode,
                });
            }
        },
    },
};

const defaultLinterRules = new Map([
    ['if-closed', IfClosed],
    ['single-selector', SingleSelector],
    ['duplicated-modifiers', DuplicatedModifiers],
    ['unknown-preprocessor-directives', UnknownPreProcessorDirectives],
    ['duplicated-hint-platforms', DuplicatedHintPlatforms],
    ['duplicated-hints', DuplicatedHints],
    ['unknown-hints-and-platforms', UnknownHintsAndPlatforms],
    ['invalid-domain-list', InvalidDomainList],
    ['invalid-modifiers', InvalidModifiers],
    ['inconsistent-hint-platforms', InconsistentHintPlatforms],
    ['no-short-rules', NoShortRules],
]);

/**
 * Represents currently supported inline config comments by AGLint.
 */
var ConfigCommentType;
(function (ConfigCommentType) {
    /**
     * Main config comment with configuration object.
     */
    ConfigCommentType["Main"] = "aglint";
    /**
     * Disables AGLint. It will be enabled again if there is an `aglint-enable` comment.
     */
    ConfigCommentType["Disable"] = "aglint-disable";
    /**
     * Enables AGLint. It will be disabled again if there is an `aglint-disable` comment.
     * If AGLint is already enabled, this comment will be ignored.
     */
    ConfigCommentType["Enable"] = "aglint-enable";
    /**
     * Disables AGLint for next line. If you specify rule names as params, then only these rules will be disabled.
     *
     * @example
     * The following comment will disable `some-rule` and `another-rule` for the next line:
     * ```adblock
     * ! aglint-disable-next-line some-rule another-rule
     * ```
     *
     * The following comment will disable all rules for the next line:
     * ```adblock
     * ! aglint-disable-next-line
     * ```
     */
    ConfigCommentType["DisableNextLine"] = "aglint-disable-next-line";
    /**
     * Enables AGLint for next line. If you specify rule names as params, then only these rules will be enabled.
     *
     * @example
     * The following comment will enable `some-rule` and `another-rule` for the next line:
     * ```adblock
     * ! aglint-enable-next-line some-rule another-rule
     * ```
     *
     * The following comment will enable all rules for the next line:
     * ```adblock
     * ! aglint-enable-next-line
     * ```
     */
    ConfigCommentType["EnableNextLine"] = "aglint-enable-next-line";
})(ConfigCommentType || (ConfigCommentType = {}));

/**
 * Validates the AGLint linter config object using Superstruct.
 *
 * @param config Config object to validate
 * @throws If the config object is not valid according to the config schema.
 */
function validateLinterConfig(config) {
    try {
        // Validate the parsed config object against the config schema using Superstruct
        assert(config, linterConfigSchema);
    }
    catch (error) {
        if (error instanceof Error) {
            // Handle Superstruct errors
            if (error instanceof StructError) {
                // We can customize the error message here to make it more user-friendly
                // https://docs.superstructjs.org/guides/05-handling-errors#customizing-errors
                const { key, value, type } = error;
                let message = EMPTY;
                if (value === undefined) {
                    message = `"${key}" is required, but it was not provided`;
                }
                else if (type === 'never') {
                    message = `"${key}" is unknown in the config schema, please remove it`;
                }
                else {
                    message = `Value "${value}" for "${key}" is not a valid "${type}" type`;
                }
                throw new Error(`Invalid linter config: ${message}`);
            }
            throw new Error(`Invalid linter config: ${error.message}`);
        }
        // Pass through any other errors
        throw error;
    }
}

/**
 * @file Configuration preset for AGLint that enables all rules.
 */
const config$1 = {
    syntax: ["Common" /* AdblockSyntax.Common */],
    rules: {
        'duplicated-hint-platforms': 'error',
        'duplicated-hints': 'error',
        'duplicated-modifiers': 'error',
        'if-closed': 'error',
        'inconsistent-hint-platforms': 'error',
        'invalid-domain-list': 'error',
        'single-selector': 'warn',
        'invalid-modifiers': 'error',
        'unknown-hints-and-platforms': 'error',
        'unknown-preprocessor-directives': 'error',
        'no-short-rules': 'error',
    },
};
var aglintAll = Object.freeze(config$1);

/**
 * @file Configuration preset for AGLint that enables recommended rules,
 * which are useful for all projects.
 */
const config = {
    syntax: ["Common" /* AdblockSyntax.Common */],
    rules: {
        'duplicated-hint-platforms': 'error',
        'duplicated-hints': 'error',
        'duplicated-modifiers': 'error',
        'if-closed': 'error',
        'inconsistent-hint-platforms': 'error',
        'invalid-domain-list': 'error',
        'invalid-modifiers': 'error',
        'unknown-hints-and-platforms': 'error',
        'unknown-preprocessor-directives': 'error',
        'no-short-rules': 'error',
    },
};
var aglintRecommended = Object.freeze(config);

const defaultConfigPresets = new Map([
    ['aglint:recommended', aglintRecommended],
    ['aglint:all', aglintAll],
]);

/**
 * @file AGLint core
 */
/**
 * Core linter logic
 */
class Linter {
    /**
     * A map of rule names to `LinterRule` objects
     */
    rules = new Map();
    /**
     * The linter configuration
     */
    config = defaultLinterConfig;
    /**
     * Config presets
     */
    configPresets = new Map();
    /**
     * Creates a new linter instance.
     *
     * @param defaultRules Add default linter rules and config presets to the linter
     * (by default it adds them)
     * @param config Linter config to use (by default it uses the default config)
     */
    constructor(defaultRules = true, config = defaultLinterConfig) {
        if (defaultRules) {
            this.addDefaultRules();
            this.addDefaultConfigPresets();
        }
        this.setConfig(config);
    }
    /**
     * Adds all default rules to the linter.
     */
    addDefaultRules() {
        for (const [name, rule] of defaultLinterRules) {
            this.addRule(name, rule);
        }
    }
    /**
     * Adds all default config presets to the linter.
     */
    addDefaultConfigPresets() {
        for (const [name, config] of defaultConfigPresets) {
            this.addConfigPreset(name, config);
        }
    }
    /**
     * Sets the config for a given rule. It just overrides the default config.
     *
     * @param ruleName The name of the rule to set the config for
     * @param ruleConfig The config to set
     * @throws If the rule doesn't exist
     * @throws If the rule severity / config is invalid
     * @throws If the rule doesn't support config
     */
    setRuleConfig(ruleName, ruleConfig) {
        const entry = this.rules.get(ruleName);
        if (!entry) {
            throw new Error(`Rule "${ruleName}" doesn't exist`);
        }
        const severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
        let config;
        if (Array.isArray(ruleConfig) && ruleConfig.length > 1) {
            const rest = ruleConfig.slice(1);
            config = rest.length === 1 ? rest[0] : rest;
        }
        if (!isSeverity(severity)) {
            throw new Error(`Invalid severity "${severity}" for rule "${ruleName}"`);
        }
        entry.severityOverride = getSeverity(severity);
        if (config !== undefined) {
            if (!entry.rule.meta.config) {
                throw new Error(`Rule "${ruleName}" doesn't support config`);
            }
            try {
                assert(config, entry.rule.meta.config.schema);
            }
            catch (err) {
                throw new Error(`Invalid config for rule "${ruleName}": ${err.message}`);
            }
            entry.configOverride = config;
        }
        this.rules.set(ruleName, entry);
    }
    /**
     * This method applies the configuration "rules" part to the linter.
     *
     * @param rulesConfig Rules config object
     */
    applyRulesConfig(rulesConfig) {
        for (const [ruleName, ruleConfig] of Object.entries(rulesConfig)) {
            this.setRuleConfig(ruleName, ruleConfig);
        }
    }
    /**
     * Gets the linter configuration.
     *
     * @returns The linter configuration
     */
    getConfig() {
        return cloneDeep(this.config);
    }
    /**
     * Adds a new config preset to the linter.
     *
     * @param name Config preset name, e.g. "aglint:recommended"
     * @param config Related config object
     * @throws If the config preset already exists
     */
    addConfigPreset(name, config) {
        // Don't allow to override existing config presets
        if (this.configPresets.has(name)) {
            throw new Error(`Config preset "${name}" already exists`);
        }
        // Validate the config
        validateLinterConfig(config);
        this.configPresets.set(name, config);
    }
    /**
     * Applies the config presets to the config object (extends the config
     * with the given presets if they exist).
     *
     * @param config Config object
     * @returns Extended config object
     * @throws If the config preset doesn't exist
     * @throws If the config is invalid
     */
    applyConfigExtensions(config) {
        // Validate the provided config before applying the config presets
        validateLinterConfig(config);
        // Clone the provided config object to avoid any side effects
        let clonedConfig = cloneDeep(config);
        // If the provided config has "extends" property,
        // presets should be merged in the same order they are specified in the "extends" array
        let mergedPresets = {};
        if (clonedConfig.extends) {
            for (const presetName of clonedConfig.extends) {
                const preset = this.configPresets.get(presetName);
                // Preset should exist
                if (!preset) {
                    throw new Error(`Config preset "${presetName}" doesn't exist`);
                }
                // TODO: Allow "extends" in config presets (recursively)?
                // ! If the config preset extends itself, we'll get an infinite loop
                // Merge the current preset with the previously merged presets
                mergedPresets = mergeConfigsReverse(mergedPresets, preset);
            }
            // Remove "extends" property from the cloned config, because we don't need it anymore
            delete clonedConfig.extends;
        }
        // Override presets with the provided config
        clonedConfig = mergeConfigsReverse(mergedPresets, clonedConfig);
        // Validate the prepared config
        validateLinterConfig(clonedConfig);
        return clonedConfig;
    }
    /**
     * Sets the linter configuration. If `reset` is set to `true`, all rule
     * configurations are reset to their default values (removing overrides).
     *
     * @param config Core linter configuration
     * @param reset Whether to reset all rule configs
     * @throws If any of the config presets doesn't exist
     * @throws If the rule config is invalid in any way
     */
    setConfig(config, reset = true) {
        // Merge the given config with the default config, but before that
        // don't forget apply the config presets
        const newConfig = mergeConfigs(defaultLinterConfig, this.applyConfigExtensions(config));
        // Set the new config
        this.config = newConfig;
        // Reset all rule configs
        if (reset) {
            for (const entry of this.rules.values()) {
                entry.configOverride = undefined;
                // By default, severity is set to 0 (which means "off")
                entry.severityOverride = 0;
            }
        }
        if (newConfig.rules) {
            this.applyRulesConfig(newConfig.rules);
        }
    }
    /**
     * Adds a new rule to the linter.
     *
     * @param name The name of the rule
     * @param rule The rule itself
     * @throws If the rule name is already taken
     */
    addRule(name, rule) {
        this.addRuleEx(name, {
            rule,
            // Initialize storage as empty object
            storage: {},
        });
    }
    /**
     * Adds a new rule to the linter, but you can specify the rule data.
     *
     * @param name The name of the rule
     * @param data The rule data, see `LinterRuleData` interface for more details
     * @throws If the rule name is already taken
     * @throws If the rule severity is invalid
     * @throws If the rule config is invalid
     */
    addRuleEx(name, data) {
        if (this.rules.has(name)) {
            throw new Error(`Rule with name "${name}" already exists`);
        }
        const clone = cloneDeep(data);
        if (clone.severityOverride) {
            // Validate severity
            if (!isSeverity(clone.severityOverride)) {
                throw new Error(`Invalid severity "${clone.severityOverride}" for rule "${name}"`);
            }
            // Convert to number
            clone.severityOverride = getSeverity(clone.severityOverride);
        }
        if (clone.configOverride) {
            if (!clone.rule.meta.config) {
                throw new Error(`Rule "${name}" doesn't support config`);
            }
            else {
                try {
                    assert(clone.configOverride, clone.rule.meta.config.schema);
                }
                catch (err) {
                    throw new Error(`Invalid config for rule "${name}": ${err.message}`);
                }
            }
        }
        // Add rule to the repository
        this.rules.set(name, clone);
    }
    /**
     * Resets default config for the rule with the specified name.
     *
     * @param name The name of the rule
     * @throws If the rule doesn't exist
     * @throws If the rule doesn't support config
     */
    resetRuleConfig(name) {
        // Find the rule
        const entry = this.rules.get(name);
        // Check if the rule exists
        if (!entry) {
            throw new Error(`Rule with name "${name}" doesn't exist`);
        }
        if (!entry.rule.meta.config) {
            throw new Error(`Rule "${name}" doesn't support config`);
        }
        // Set the config to undefined, so the default config will be used next time
        entry.severityOverride = undefined;
        entry.configOverride = undefined;
    }
    /**
     * Gets the current config for the rule with the specified name.
     *
     * @param name The name of the rule
     * @returns The currently active config for the rule. If no override is set,
     * the default config is returned.
     * @throws If the rule doesn't exist
     * @throws If the rule doesn't support config
     */
    getRuleConfig(name) {
        // Find the rule
        const entry = this.rules.get(name);
        // Check if the rule exists
        if (!entry) {
            throw new Error(`Rule with name "${name}" doesn't exist`);
        }
        if (!entry.rule.meta.config) {
            throw new Error(`Rule "${name}" doesn't support config`);
        }
        return [
            isSeverity(entry.severityOverride) ? entry.severityOverride : entry.rule.meta.severity,
            entry.configOverride || entry.rule.meta.config.default,
        ];
    }
    /**
     * Returns the `LinterRule` object with the specified name.
     *
     * @param name - The name of the rule
     * @returns The `LinterRule` object, or `undefined` if no such rule exists
     */
    getRule(name) {
        return cloneDeep(this.rules.get(name)?.rule);
    }
    /**
     * Returns the map of all rules in the repository.
     *
     * @returns The map of rule names to `LinterRule` objects
     */
    getRules() {
        return cloneDeep(this.rules);
    }
    /**
     * Returns whether a rule with the specified name exists in the repository.
     *
     * @param name - The name of the rule
     * @returns `true` if the rule exists, `false` otherwise
     */
    hasRule(name) {
        return this.rules.has(name);
    }
    /**
     * Removes a rule from the repository.
     *
     * @param name - The name of the rule
     */
    removeRule(name) {
        if (!this.rules.has(name)) {
            throw new Error(`Rule with name "${name}" does not exist`);
        }
        this.rules.delete(name);
    }
    /**
     * Disables a rule by name.
     *
     * @param name - The name of the rule
     * @throws If the rule does not exist
     */
    disableRule(name) {
        const entry = this.rules.get(name);
        // Check if the rule exists
        if (!entry) {
            throw new Error(`Rule with name "${name}" does not exist`);
        }
        entry.severityOverride = SEVERITY.off;
        this.rules.set(name, entry);
    }
    /**
     * Enables a rule
     *
     * @param name - The name of the rule
     * @throws If the rule does not exist
     */
    enableRule(name) {
        const entry = this.rules.get(name);
        // Check if the rule exists
        if (!entry) {
            throw new Error(`Rule with name "${name}" does not exist`);
        }
        entry.severityOverride = undefined;
        this.rules.set(name, entry);
    }
    /**
     * Returns whether a rule is disabled.
     *
     * @param name - The name of the rule
     * @returns `true` if the rule is disabled, `false` otherwise
     */
    isRuleDisabled(name) {
        const entry = this.rules.get(name);
        if (!entry) {
            return false;
        }
        const severity = isSeverity(entry.severityOverride) ? entry.severityOverride : entry.rule.meta.severity;
        // Don't forget to convert severity to number (it can be a string,
        // if it was set by the user, and it's can be confusing)
        return getSeverity(severity) === SEVERITY.off;
    }
    /**
     * Lints the list of rules (typically this is the content of a filter list).
     *
     * @param content - Filter list content
     * @param fix - Include fixes in the result. Please note that if more than one fix
     * is available for a single problem, then the line will be skipped.
     * @returns Linter result
     */
    lint(content, fix = false) {
        // Prepare linting result
        const result = {
            problems: [],
            warningCount: 0,
            errorCount: 0,
            fatalErrorCount: 0,
        };
        let isDisabled = false;
        // A set of linter rule names that are disabled on the next line
        const nextLineDisabled = new Set();
        let isDisabledForNextLine = false;
        // A set of linter rule names that are enabled on the next line
        const nextLineEnabled = new Set();
        let isEnabledForNextLine = false;
        // Store the actual line number here for the context object
        let actualLine = 0;
        // Store the actual rule here for the context object
        let actualAdblockRuleAst;
        let actualAdblockRuleRaw;
        /**
         * Invokes an event for all rules. This function is only used internally
         * by the actual linting, so we define it here.
         *
         * The context is dependent on the actual linting environment, so we create
         * a new context object for each event within this function.
         *
         * @param event - The event to invoke (e.g. `onRule`)
         */
        const invokeEvent = (event) => {
            for (const [name, data] of this.rules) {
                // If the rule is disabled, skip it
                if ((this.isRuleDisabled(name) // rule is disabled at config level
                    || nextLineDisabled.has(name)) // or rule is disabled for the next line
                    && !nextLineEnabled.has(name) // and rule is not enabled for the next line
                ) {
                    continue;
                }
                // Validate rule configuration (if it exists)
                if (data.rule.meta.config) {
                    assert(data.configOverride || data.rule.meta.config.default, data.rule.meta.config.schema);
                }
                const genericContext = Object.freeze({
                    // Deep copy of the linter configuration
                    getLinterConfig: () => {
                        return { ...this.config };
                    },
                    // Currently linted filter list content
                    getFilterListContent: () => content,
                    fixingEnabled: () => fix,
                    // Storage reference
                    storage: data.storage,
                    // Rule configuration
                    config: data.configOverride || data.rule.meta.config?.default,
                    // Reporter function
                    // eslint-disable-next-line @typescript-eslint/no-loop-func
                    report: (problem) => {
                        let severity = getSeverity(data.rule.meta.severity);
                        if (!nextLineEnabled.has(name)) {
                            // rely on the result of network rules modifiers validation;
                            // see src/linter/rules/invalid-modifiers.ts
                            if (isSeverity(problem.customSeverity)) {
                                severity = getSeverity(problem.customSeverity);
                            }
                            else if (isSeverity(data.severityOverride)) {
                                severity = getSeverity(data.severityOverride);
                            }
                        }
                        // Default problem location: whole line
                        let position = {
                            startLine: actualLine,
                            startColumn: 0,
                            endLine: actualLine,
                            endColumn: actualAdblockRuleRaw.length,
                        };
                        if (problem.position) {
                            position = problem.position;
                        }
                        else if (problem.node && problem.node.loc !== undefined) {
                            position = {
                                startLine: problem.node.loc.start.line,
                                startColumn: problem.node.loc.start.column - 1,
                                endLine: problem.node.loc.end.line,
                                endColumn: problem.node.loc.end.column - 1,
                            };
                        }
                        result.problems.push({
                            rule: name,
                            severity,
                            message: problem.message,
                            position,
                            fix: problem.fix,
                        });
                        // Update problem counts
                        switch (severity) {
                            case SEVERITY.warn:
                                result.warningCount += 1;
                                break;
                            case SEVERITY.error:
                                result.errorCount += 1;
                                break;
                            case SEVERITY.fatal:
                                result.fatalErrorCount += 1;
                                break;
                        }
                    },
                });
                // Call the proper event handler
                if (event !== 'onRule') {
                    const handler = data.rule.events[event];
                    if (handler) {
                        handler(genericContext);
                    }
                }
                else {
                    const handler = data.rule.events.onRule;
                    if (handler) {
                        handler(Object.freeze({
                            ...genericContext,
                            // eslint-disable-next-line @typescript-eslint/no-loop-func
                            getActualLine: () => actualLine,
                            // Currently iterated adblock rule
                            // eslint-disable-next-line @typescript-eslint/no-loop-func
                            getActualAdblockRuleAst: () => actualAdblockRuleAst,
                            // Currently iterated adblock rule
                            // eslint-disable-next-line @typescript-eslint/no-loop-func
                            getActualAdblockRuleRaw: () => actualAdblockRuleRaw,
                        }));
                    }
                }
            }
        };
        // Invoke onStartFilterList event before parsing the filter list
        invokeEvent('onStartFilterList');
        // Parse the filter list
        const filterList = FilterListParser.parse(content);
        // Iterate over all filter list adblock rules
        filterList.children.forEach((ast, index) => {
            // Update actual line number for the context object
            actualLine = index + 1;
            // Process the line
            const code = (() => {
                // Invalid rules
                if (ast.category === "Invalid" /* RuleCategory.Invalid */) {
                    // If the linter is actually disabled, skip the error reporting
                    if ((isDisabled || isDisabledForNextLine) && !isEnabledForNextLine) {
                        return 0;
                    }
                    // If an error occurs during parsing, it means that the rule is invalid,
                    // that is, it could not be parsed for some reason. This is a fatal error,
                    // since the linter rules can only accept AST.
                    // AdblockSyntaxError is a special error type that is thrown by the parser
                    // when it encounters a syntax error. In this case, we can get the position
                    // of the error from the error object.
                    // Otherwise, we assume that the error occurred at the beginning of the line
                    // and we report the error for the entire line (from the beginning to the end).
                    /* eslint-disable @typescript-eslint/no-non-null-assertion */
                    const position = {
                        startLine: ast.error.loc.start.line,
                        startColumn: ast.error.loc.start.column - 1,
                        endLine: ast.error.loc.end.line,
                        endColumn: ast.error.loc.end.column - 1,
                    };
                    /* eslint-enable @typescript-eslint/no-non-null-assertion */
                    // Store the error in the result object
                    result.problems.push({
                        severity: SEVERITY.fatal,
                        message: `AGLint parsing error: ${ast.error.message}`,
                        position,
                    });
                    // Don't forget to increase the fatal error count when parsing fails
                    result.fatalErrorCount += 1;
                }
                else {
                    // Handle inline config comments
                    if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "ConfigCommentRule" /* CommentRuleType.ConfigCommentRule */) {
                        // If inline config is not allowed in the linter configuration,
                        // simply skip the comment processing
                        if (!this.config.allowInlineConfig) {
                            return 0;
                        }
                        // Process the inline config comment
                        switch (ast.command.value) {
                            case ConfigCommentType.Main: {
                                if (ast.params && ast.params.type === 'Value') {
                                    assert(ast.params.value, linterRulesSchema);
                                    this.config = mergeConfigs(this.config, {
                                        rules: ast.params.value,
                                    });
                                    this.applyRulesConfig(ast.params.value);
                                }
                                break;
                            }
                            case ConfigCommentType.Disable: {
                                if (ast.params && ast.params.type === 'ParameterList') {
                                    for (const param of ast.params.children) {
                                        this.disableRule(param.value);
                                    }
                                    break;
                                }
                                isDisabled = true;
                                break;
                            }
                            case ConfigCommentType.Enable: {
                                if (ast.params && ast.params.type === 'ParameterList') {
                                    for (const param of ast.params.children) {
                                        this.enableRule(param.value);
                                    }
                                    break;
                                }
                                isDisabled = false;
                                break;
                            }
                            case ConfigCommentType.DisableNextLine: {
                                // Disable specific rules for the next line
                                if (ast.params && ast.params.type === 'ParameterList') {
                                    for (const param of ast.params.children) {
                                        nextLineDisabled.add(param.value);
                                    }
                                }
                                else {
                                    // Disable all rules for the next line
                                    isDisabledForNextLine = true;
                                }
                                break;
                            }
                            case ConfigCommentType.EnableNextLine: {
                                // Enable specific rules for the next line
                                if (ast.params && ast.params.type === 'ParameterList') {
                                    for (const param of ast.params.children) {
                                        nextLineEnabled.add(param.value);
                                    }
                                }
                                else {
                                    // Disable all rules for the next line
                                    isEnabledForNextLine = true;
                                }
                                break;
                            }
                        }
                        // The config comment has been processed, there is nothing more to do with the line
                        // But we need to return 1, because we processed an inline config comment
                        return 1;
                    }
                    // If the linter is actually disabled, skip the rule processing.
                    // It is important to do this check here, because we need to
                    // process the inline config comments even if the linter is disabled
                    // (in this way we could detect the `enable` command, for example).
                    if ((isDisabled || isDisabledForNextLine) && !isEnabledForNextLine) {
                        return 0;
                    }
                    // Deep copy of the line data
                    actualAdblockRuleAst = { ...ast };
                    // It is safe to use the `!` operator here, because we know that the `raws` property exists,
                    // since we configured the parser to return the raw data as well.
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    actualAdblockRuleRaw = ast.raws.text;
                    // Invoke onRule event for all rules (process actual adblock rule)
                    invokeEvent('onRule');
                    // Check if filter list has Agent type comment
                    // and if so, it will override the syntax property set in the config
                    if (ast.category === "Comment" /* RuleCategory.Comment */ && ast.type === "AgentCommentRule" /* CommentRuleType.AgentCommentRule */) {
                        const agents = [];
                        ast.children.forEach((child) => {
                            if (child.type === 'Agent') {
                                agents.push(child.syntax);
                            }
                        });
                        this.config.syntax = agents.length > 0
                            ? agents
                            : ["Common" /* AdblockSyntax.Common */];
                    }
                }
                return 0;
            })();
            // Clear next line stuff if the line was processed with code 0
            if (code === 0) {
                nextLineDisabled.clear();
                nextLineEnabled.clear();
                isDisabledForNextLine = false;
                isEnabledForNextLine = false;
            }
        });
        // Invoke onEndFilterList event after parsing the filter list
        invokeEvent('onEndFilterList');
        // Build fixed content if fixing is enabled
        if (fix) {
            const fixedFilterList = {
                type: 'FilterList',
                children: [],
            };
            // Iterate over all rules in the original filter list
            for (let i = 0; i < filterList.children.length; i += 1) {
                const rule = filterList.children[i];
                // Find the fix for the current rule
                const fixed = [];
                // Currently only 1 fix is allowed per rule
                let matches = 0;
                for (const problem of result.problems) {
                    if (problem.fix && problem.position.startLine === i + 1 && i + 1 === problem.position.endLine) {
                        const fixes = Array.isArray(problem.fix) ? problem.fix : [problem.fix];
                        // We prefer to use raw generated content if available, so
                        // we can avoid generating wrong (old) content again, if
                        // the rule was changed in the meantime
                        fixed.push(...(fixes.map((e) => {
                            if (e.raws && e.raws.text) {
                                delete e.raws.text;
                            }
                            return e;
                        })));
                        matches += 1;
                    }
                }
                // Push the fixed version of the rule to the fixed filter list if
                // matches is 1 (only 1 fix is allowed per rule), otherwise push
                // the original rule
                if (matches === 1) {
                    fixedFilterList.children.push(...fixed);
                }
                else {
                    fixedFilterList.children.push(rule);
                }
            }
            result.fixed = FilterListParser.generate(fixedFilterList, true);
        }
        // Return linting result
        return result;
    }
}

const version$1 = "2.0.9";

/**
 * @file AGLint version
 */
// ! Notice:
// Don't export version from package.json directly, because if you run
// `tsc` in the root directory, it will generate `dist/types/src/version.d.ts`
// with wrong relative path to `package.json`. So we need this little "hack"
const version = version$1;

const CONFIG_FILE = 'aglint.config';
const RC_CONFIG_FILE = '.aglintrc';
const EXT_JSON = '.json';
const EXT_YAML = '.yaml';
const EXT_YML = '.yml';
const JSON_CONFIG_FILE_NAME = `${CONFIG_FILE}${EXT_JSON}`;
const YAML_CONFIG_FILE_NAME = `${CONFIG_FILE}${EXT_YAML}`;
const YML_CONFIG_FILE_NAME = `${CONFIG_FILE}${EXT_YML}`;
const JSON_RC_CONFIG_FILE_NAME = `${RC_CONFIG_FILE}${EXT_JSON}`;
const YAML_RC_CONFIG_FILE_NAME = `${RC_CONFIG_FILE}${EXT_YAML}`;
const YML_RC_CONFIG_FILE_NAME = `${RC_CONFIG_FILE}${EXT_YML}`;
/**
 * Possible names of the config file
 */
const CONFIG_FILE_NAMES = new Set([
    // aglint.config stuff
    JSON_CONFIG_FILE_NAME,
    YAML_CONFIG_FILE_NAME,
    YML_CONFIG_FILE_NAME,
    // .aglintrc stuff
    RC_CONFIG_FILE,
    JSON_RC_CONFIG_FILE_NAME,
    YAML_RC_CONFIG_FILE_NAME,
    YML_RC_CONFIG_FILE_NAME,
]);
/**
 * Name of the ignore file
 */
const IGNORE_FILE_NAME = '.aglintignore';
/**
 * Supported file extensions for lintable files. Text is the most important one, but we also
 * support other possible extensions, which may occur in some cases.
 */
const SUPPORTED_EXTENSIONS = new Set([
    '.txt',
    '.adblock',
    '.adguard',
    '.ublock',
]);
/**
 * Problematic paths that should be ignored by default. This is essential to provide a good
 * experience for the user.
 */
const PROBLEMATIC_PATHS = [
    'node_modules',
    '.git',
    '.hg',
    '.svn',
    '.DS_Store',
    'Thumbs.db',
];

/**
 * Reads and parses supported configuration files.
 *
 * @param filePath - The name of the configuration file to be read and parsed.
 * @returns The parsed config object.
 * @throws If the file not found or the file extension is not supported.
 * @throws If the file contents are not valid JSON or YAML.
 * @throws If the file contents are not valid according to the config schema.
 */
async function parseConfigFile(filePath) {
    try {
        // Determine the file extension
        const parsedFilePath = parse(filePath);
        // Read the file contents
        const contents = await readFile(filePath, 'utf8');
        // At this point, we don't know exactly what the file contains, so simply mark
        // it as unknown, later we validate it anyway
        let parsed;
        if (parsedFilePath.base === RC_CONFIG_FILE) {
            parsed = JSON.parse(contents);
        }
        else {
            // Parse the file contents based on the extension
            switch (parsedFilePath.ext) {
                case EXT_JSON: {
                    // Built-in JSON parser
                    parsed = JSON.parse(contents);
                    break;
                }
                case EXT_YAML:
                case EXT_YML: {
                    // Well-tested external YAML parser
                    parsed = yaml.load(contents);
                    break;
                }
                // TODO: Implement support for JS/TS config files
                default: {
                    throw new Error(`Unsupported config file extension "${parsedFilePath.ext}"`);
                }
            }
        }
        // Validate the parsed config object against the config schema using Superstruct
        validateLinterConfig(parsed);
        return parsed;
    }
    catch (error) {
        if (error instanceof Error) {
            throw new Error(`Failed to parse config file "${filePath}": ${error.message}`);
        }
        // Pass through any other errors
        throw error;
    }
}

/**
 * Walks a `ScannedDirectory` object and performs an action on each file and directory
 * in the tree.
 *
 * @param scannedDirectory The `ScannedDirectory` object to be walked
 * @param events The events to be performed on each file and directory
 * @param config The CLI config
 * @param fix Fix fixable problems automatically
 */
async function walk(scannedDirectory, events, config, fix = false) {
    // Initially the used config is the provided config
    let usedConfig = config;
    // But if the directory contains a config file, we merge two configs
    if (scannedDirectory.configFile) {
        const filePath = path.join(scannedDirectory.configFile.dir, scannedDirectory.configFile.base);
        const fileConfig = await parseConfigFile(filePath);
        usedConfig = mergeConfigs(usedConfig, fileConfig);
    }
    // Make a deep clone of the config so that it can be modified without affecting the original
    // in any way
    const configDeepClone = cloneDeep(usedConfig);
    // Perform the directory action on the current directory (if it exists)
    if (events.dir) {
        await events.dir(scannedDirectory.dir, configDeepClone, fix);
    }
    // Perform the file action on each lintable file
    for (const file of scannedDirectory.lintableFiles) {
        await events.file(file, configDeepClone, fix);
    }
    // Recursively walk each subdirectory
    for (const subDir of scannedDirectory.subdirectories) {
        await walk(subDir, events, configDeepClone, fix);
    }
}

/**
 * Ignore instance for the default ignores
 */
const defaultIgnores = ignore().add(PROBLEMATIC_PATHS);
/**
 * Searches for lintable files in a directory recursively. Practically it means files with the
 * supported extensions. It will also search for config files.
 *
 * It will ignore files and directories that are ignored by the ignore file at any level.
 * `.aglintignore` works exactly like `.gitignore`.
 *
 * @param dir Directory to search in
 * @param ignores File ignores
 * @param useIgnoreFiles Use ignore files or not (default: true)
 * @returns The result of the scan (`ScannedDirectory` object)
 * @throws If multiple config files are found in the given directory
 */
async function scan(dir, ignores = [], useIgnoreFiles = true) {
    // Initialize an empty result
    const result = {
        dir: path.parse(path.join(dir)),
        configFile: null,
        lintableFiles: [],
        subdirectories: [],
    };
    // Get all files in the directory
    const items = await readdir(dir);
    // First of all, let's parse the ignore file in the current directory if ignore files are
    // enabled and the ignore file exists
    if (useIgnoreFiles && items.includes(IGNORE_FILE_NAME)) {
        const content = await readFile(path.join(dir, IGNORE_FILE_NAME), 'utf8');
        ignores.push(ignore().add(content));
    }
    // Loop through all items in the directory
    for (const item of items) {
        // If the current item is ignored by the default ignores, skip it
        if (defaultIgnores.ignores(item)) {
            continue;
        }
        // If the current item is ignored by the ignore files, skip it (if ignore files are enabled)
        if (useIgnoreFiles && ignores.some((i) => i.ignores(item))) {
            continue;
        }
        // Get the full path of the current item within the directory structure,
        // then get the stats of the item
        const itemPath = path.join(dir, item);
        const stats = await stat(itemPath);
        if (stats.isFile()) {
            // Parse path
            const parsedPath = path.parse(itemPath);
            // If the file is a config file
            if (CONFIG_FILE_NAMES.has(item)) {
                // If a config file is already found, throw an error
                if (result.configFile !== null) {
                    throw new Error(`Multiple config files found in the same directory: "${path.join(result.configFile.dir, result.configFile.base)}" and "${itemPath}"`);
                }
                // Otherwise, set the config file for the current directory
                result.configFile = parsedPath;
            }
            else if (SUPPORTED_EXTENSIONS.has(parsedPath.ext)) {
                // We only want to lint files with the supported extensions
                result.lintableFiles.push(parsedPath);
            }
        }
        else if (stats.isDirectory()) {
            // If the current item is a directory, recursively scan it, then
            // merge the subdirectory result into the current result
            result.subdirectories.push(await scan(itemPath, ignores, useIgnoreFiles));
        }
    }
    return result;
}

const UPPER_DIR = '..';
/**
 * Discovers every AGLint config files in the current working directory and its parent directories.
 * It only checks file names, not the contents of the files, so it doesn't validate the config files.
 * If you didn't abort the search meanwhile, it will scan until it reaches the root directory.
 *
 * @param cwd Current working directory
 * @param callback Callback function that will be called with the path to the config file
 * if it is found
 * @throws If multiple config files are found in the same directory
 */
async function configFinder(cwd, callback) {
    // Start with the current working directory
    let dir = resolve(cwd);
    // Keep searching for a config file until we reach the root directory
    do {
        // Get the list of files in the current directory
        const files = await readdir(dir);
        // Collect all config files in the current directory
        const configFiles = files.filter((file) => CONFIG_FILE_NAMES.has(file));
        if (configFiles.length === 1) {
            // If there is only one config file, call the callback with the path to the config file
            // If the callback returned `true`, stop the search
            if (await callback(join(dir, configFiles[0])) === true) {
                return;
            }
        }
        else if (configFiles.length > 1) {
            // If there are multiple config files, throw an error
            throw new Error(`Multiple config files found in ${dir}`);
        }
        // If there are no config files, go one directory up and try again
        dir = join(dir, UPPER_DIR);
    } while (dir !== resolve(dir, UPPER_DIR));
}
/**
 * Finds the next config file in the current working directory and its parent directories.
 * It just searches for the first config file and returns its path.
 *
 * @param cwd Current working directory
 * @throws If multiple config files are found in the same directory
 * @throws If a config file is found, but it is not valid
 * @returns The path to the config file and the parsed config object or `null` if no config file was found
 */
async function findNextConfig(cwd) {
    let configPath = null;
    let config = null;
    // Search for a config file in the current working directory and its parent directories
    // (callback may not be called if no config file is found at all)
    await configFinder(cwd, async (path) => {
        // If the callback is called, it means that a config file was found, so parse it
        // and save the path to the config file
        config = await parseConfigFile(path);
        configPath = path;
        // Stop the search, no need to continue
        return true;
    });
    // If a config file was found, return its path and the parsed config
    if (configPath && config) {
        return {
            path: configPath,
            config,
        };
    }
    // Otherwise, return null
    return null;
}
/**
 * Finds the first root config file in the current working directory and its parent directories.
 * It parses the config files and stops the search when it finds the root config file, which
 * is the first config file that has the "root" property set to `true`.
 *
 * If it doesn't find a root config file, but it finds a config file, it will return the first
 * config file.
 *
 * @param cwd Current working directory
 * @throws If multiple config files are found in the same directory
 * @throws If a config file is found, but it is not valid
 * @returns The path to the config file and the parsed config object or `null` if no config file was found
 */
async function findNextRootConfig(cwd) {
    let configPath = null;
    let config = null;
    // Search for a config file in the current working directory and its parent directories
    // (callback may not be called if no config file is found at all)
    await configFinder(cwd, async (path) => {
        // If the callback is called, it means that a config file was found, so parse it
        // and save the path to the config file
        config = await parseConfigFile(path);
        // If the config file has the "root" property set to `true`, stop the search,
        // because we prefer root config files over non-root config files
        if (config.root === true) {
            configPath = path;
            // Stop the search, no need to continue
            return true;
        }
        // Save the path to the first config file, if it wasn't saved yet
        if (!configPath) {
            configPath = path;
        }
        // Otherwise, continue the search
        return false;
    });
    // If a config file was found, return its path and the parsed config
    if (configPath && config) {
        return {
            path: configPath,
            config,
        };
    }
    // Otherwise, return null
    return null;
}

/**
 * We throw this error when we can't find a config file for the given directory.
 * It is easy to catch this error and show a nice error message to the user
 * when using the CLI tool.
 */
class NoConfigError extends Error {
    constructor(dir) {
        super(`No config file found for ${dir}`);
        this.name = 'NoConfigError';
    }
}

/**
 * Constructs a config object for the given directory by merging all config files
 * from the root config file to the actual directory. It searches all config files
 * in the upper directories until it finds a root config file or the actual directory
 * is the root directory, then it merges the config files from the root directory
 * to the actual directory after each other. This will results the corresponding
 * config object for the given directory. Works same as ESLint.
 *
 * @param dir Base directory
 * @returns Config object
 * @throws If no config file was found
 * @throws If a config file is found, but it is not valid
 * @throws If multiple config files are found in the same directory
 */
async function buildConfigForDirectory(dir) {
    const parsedConfigs = [];
    // Finds config files from the actual directory to the root directory.
    // It starts from the actual directory and goes up to the root directory
    // until it finds a root config file or the actual directory is the root directory.
    //
    // In other words, it pushes the config files to the `parsedConfigs` array
    // in this order:
    //   - actual directory
    //   - parent directory
    //   - ...
    //   - root config
    //
    // (Of course, if the actual directory contains a root config file or the
    // actual directory is the root directory, then only 1 config file will be
    // pushed to the array - but the philosophy is the same.)
    await configFinder(dir, async (path) => {
        const parsedConfig = await parseConfigFile(path);
        parsedConfigs.push(parsedConfig);
        // Abort the search if the config file is a root config file
        return parsedConfig.root === true;
    });
    // If no config file was found, throw an error, because we definitely need a config file
    if (parsedConfigs.length === 0) {
        throw new NoConfigError(dir);
    }
    // If there is only one config file, just return it, no need to do anything else
    if (parsedConfigs.length === 1) {
        return parsedConfigs[0];
    }
    // We should merge the config files from the root directory to the actual directory.
    // In other words, we should merge the config files in this order:
    //   - root config
    //   - ...
    //   - parent directory
    //   - actual directory
    //
    // But we pushed the config files to the `parsedConfigs` array in the following order:
    //   - actual directory
    //   - parent directory
    //   - ...
    //   - root config
    //
    // So we have to reverse the array first, then merge the config files in the reversed order.
    const mergedConfig = parsedConfigs.reduceRight((prev, curr) => mergeConfigs(prev, curr));
    // Make sure that the config object is not mutated
    return cloneDeep(mergedConfig);
}

/**
 * Implements CLI functionality for the linter. Typically used by the `aglint` command in Node.js environment.
 */
class LinterCli {
    /**
     * The reporter to be used for the CLI.
     */
    reporter;
    fix;
    ignore;
    errors;
    /**
     * Creates a new `LinterCli` instance.
     *
     * @param reporter The reporter to be used for the CLI
     * @param fix Fix fixable problems automatically
     * @param ignore Use `.aglintignore` files
     */
    constructor(reporter, fix = false, ignore = true) {
        this.reporter = reporter;
        this.fix = fix;
        this.ignore = ignore;
        this.errors = false;
    }
    /**
     * Lints a file with the given config. Also compatible with the `WalkEvent` type,
     * so it can be used with the `walk` function.
     *
     * @param file The file to be linted
     * @param config The active linter config (merged from parent directories)
     */
    lintFile = async (file, config) => {
        // Create a new linter instance and add the default rules
        const linter = new Linter(true, config);
        // Get the file path from the current directory
        const filePath = path.join(file.dir, file.base);
        // Clone the config in order to prevent unwanted changes
        const configDeepClone = cloneDeep(config);
        // If the reporter has an onFileStart event, call it
        if (this.reporter.onFileStart) {
            this.reporter.onFileStart(file, configDeepClone);
        }
        // Lint the file
        let result = linter.lint(await readFile(filePath, 'utf8'), this.fix || false);
        // Set the errors flag if there are any errors
        if (!this.errors && (result.errorCount > 0 || result.fatalErrorCount > 0)) {
            this.errors = true;
        }
        // If fix is enabled and fixable problems were found, write the fixed file,
        // then re-lint the fixed file to see if there are still problems
        if (this.fix) {
            if (result.fixed) {
                await writeFile(filePath, result.fixed);
                // TODO: Currently fixing runs only once, but it should run until there are no more fixable problems
                result = linter.lint(result.fixed, this.fix || false);
            }
        }
        // If the reporter has an onFileStart event, call it
        if (this.reporter.onFileEnd) {
            this.reporter.onFileEnd(file, result, configDeepClone);
        }
    };
    /**
     * Returns true if the linter found any errors.
     *
     * @returns `true` if the linter found any errors, `false` otherwise
     */
    hasErrors = () => {
        return this.errors;
    };
    /**
     * Lints the current working directory. If you specify files, it will only lint those files.
     *
     * @param cwd The current working directory
     * @param files The files to be linted (if not specified, it will scan the cwd)
     */
    run = async (cwd, files = []) => {
        // If the reporter has an onLintStart event, call it
        if (this.reporter.onLintStart) {
            this.reporter.onLintStart();
        }
        // If files are specified, use them instead of scanning the cwd
        if (files.length > 0) {
            for (const file of files) {
                let fullPath;
                if (path.isAbsolute(file)) {
                    // If file path is absolute, use it as is
                    fullPath = file;
                }
                else {
                    // Otherwise, join relative path with cwd
                    fullPath = path.join(cwd, file);
                }
                // TODO: Add support for glob patterns
                // Check if the file exists
                if (!(await pathExists(fullPath))) {
                    throw new Error(`File "${fullPath}" does not exist`);
                }
                // Parse the file path
                const parsedFile = path.parse(fullPath);
                // Get config for the directory where the file is located
                const config = await buildConfigForDirectory(parsedFile.dir);
                // Lint the file
                await this.lintFile(parsedFile, config);
            }
        }
        else {
            // Get the config for the cwd, should exist
            const rootConfig = await buildConfigForDirectory(cwd);
            if (!rootConfig) {
                throw new NoConfigError(cwd);
            }
            // Run the scanner on the cwd
            const scanResult = await scan(cwd, [], this.ignore);
            // Walk through the scanned directory and lint all files
            await walk(scanResult, {
                // Call the lint function for each file during the walk
                file: this.lintFile,
            }, 
            // Use cwd config as base config for the walker
            rootConfig, this.fix);
        }
        // If the reporter has an onLintEnd event, call it
        if (this.reporter.onLintEnd) {
            this.reporter.onLintEnd();
        }
    };
}

const ALIGN_LEFT = 'l';
const ALIGN_CENTER = 'c';
/**
 * Implements a simple reporter that logs the problems to the console.
 * You can implement any reporter you want, as long as it implements the
 * `LinterCliReporter` interface.
 */
class LinterConsoleReporter {
    /**
     * We save the start time here, so we can calculate the total time at the end.
     */
    startTime = null;
    /**
     * Custom Chalk instance to use for coloring the console output.
     */
    chalk;
    /**
     * Total number of warnings
     */
    warnings = 0;
    /**
     * Total number of errors
     */
    errors = 0;
    /**
     * Total number of fatal errors
     */
    fatals = 0;
    /**
     * Creates a new console reporter instance.
     *
     * @param colors Whether to use colors in the console output or not
     */
    constructor(colors = true) {
        // By default, Chalk determines the color support automatically, but we
        // want to disable colors if the user doesn't want them.
        const chalkOptions = colors ? {} : { level: 0 };
        this.chalk = new chalk.Instance(chalkOptions);
    }
    /**
     * Collected problems, where the key is the file path and the value is an array of problems.
     * We only collect problems here, we don't log them, because we want to log them in the end.
     */
    problems = {};
    onLintStart = () => {
        // Save the start time
        this.startTime = performance.now();
    };
    onFileStart = (file) => {
        // Initialize the problems array for the file as empty
        this.problems[path.join(file.dir, file.base)] = [];
    };
    onFileEnd = (file, result) => {
        // Initialize the problems array for the file as empty
        this.problems[path.join(file.dir, file.base)].push(...result.problems);
        // Count the problems
        this.warnings += result.warningCount;
        this.errors += result.errorCount;
        this.fatals += result.fatalErrorCount;
    };
    onLintEnd = () => {
        // Calculate the linting time
        // eslint-disable-next-line max-len
        const lintTime = Math.round(((this.startTime ? performance.now() - this.startTime : 0) + Number.EPSILON) * 100) / 100;
        let output = EMPTY;
        let timeOutput = EMPTY;
        if (lintTime > 0) {
            timeOutput += `Linting took ${this.chalk.dim(lintTime)} ms.`;
        }
        else {
            timeOutput += this.chalk.red('Error: Could not calculate linting time.');
        }
        // If there are no problems, log that there are no problems
        if (this.warnings === 0 && this.errors === 0 && this.fatals === 0) {
            output += this.chalk.green('No problems found!');
            output += DOUBLE_NEWLINE;
            output += timeOutput;
            // eslint-disable-next-line no-console
            console.log(output);
            return;
        }
        // If there are problems, log them to the console
        for (const [file, problems] of Object.entries(this.problems)) {
            // Typically when found problems are fixed
            if (problems.length === 0) {
                continue;
            }
            output += this.chalk.underline(file);
            output += NEWLINE;
            const rows = [];
            for (const problem of problems) {
                const row = [];
                // Column 1: Empty column
                row.push(EMPTY);
                // Column 2: Problem location
                row.push(`${problem.position.startLine}:${problem.position.startColumn !== undefined ? problem.position.startColumn : 0}`);
                // Column 3: Problem type
                switch (problem.severity) {
                    case 1: {
                        row.push(this.chalk.yellow('warn'));
                        break;
                    }
                    case 2: {
                        row.push(this.chalk.red('error'));
                        break;
                    }
                    case 3: {
                        row.push(this.chalk.red('fatal'));
                        break;
                    }
                    default: {
                        row.push(this.chalk.red('error'));
                    }
                }
                // Column 4: Problem description
                row.push(problem.message);
                // Column 5: Linter rule name (if available)
                if (problem.rule) {
                    // Some terminals support links, so we can link to the rule documentation directly
                    // in this case.
                    if (terminalLink.isSupported) {
                        row.push(terminalLink(problem.rule, `${REPO_URL}${HASHMARK}${problem.rule}`));
                    }
                    else {
                        row.push(this.chalk.dim(problem.rule));
                    }
                }
                else {
                    row.push(EMPTY);
                }
                rows.push(row);
            }
            if (rows.length > 0) {
                output += table(rows, {
                    align: [ALIGN_LEFT, ALIGN_CENTER, ALIGN_LEFT, ALIGN_LEFT, ALIGN_LEFT],
                    stringLength(str) {
                        return stripAnsi(str).length;
                    },
                });
                output += DOUBLE_NEWLINE;
            }
        }
        const anyErrors = this.errors > 0 || this.fatals > 0;
        const total = this.warnings + this.errors + this.fatals;
        // Stats
        output += 'Found';
        output += SPACE;
        output += this.chalk[anyErrors ? 'red' : 'yellow'](total);
        output += SPACE;
        output += inflect('problem', total);
        output += SPACE + OPEN_PARENTHESIS;
        // Warnings
        output += this.chalk.yellow(`${this.warnings} ${inflect('warning', this.warnings)}`);
        output += COMMA + SPACE;
        // Errors
        output += this.chalk.red(`${this.errors} ${inflect('error', this.errors)}`);
        output += SPACE;
        output += 'and';
        output += SPACE;
        // Fatal errors
        output += this.chalk.red(`${this.fatals} fatal ${inflect('error', this.fatals)}`);
        output += CLOSE_PARENTHESIS + DOT + DOUBLE_NEWLINE;
        // Linting time
        output += timeOutput;
        // eslint-disable-next-line no-console
        console[anyErrors ? 'error' : 'warn'](output);
    };
}

export { Linter, LinterCli, LinterConsoleReporter, NoConfigError, buildConfigForDirectory, configFinder, findNextConfig, findNextRootConfig, parseConfigFile, scan, version, walk };
